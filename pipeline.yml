# azure-pipelines.yml
trigger:
- none
parameters:
- name: environment
  displayName: Environment to scan
  type: string
  default: 'dev'
  values:
  - 'dev'
  - 'qa'
  - 'prod'
- name: scanType
  displayName: Type of ZAP scan
  type: string
  default: 'baseline'
  values:
  - 'baseline'
  - 'full'
  - 'api'
- name: reportTemplate
  displayName: ZAP Report Template
  type: string
  default: 'modern'
  values:
  - 'modern'
  - 'traditional-html'
  - 'traditional-html-plus'
  - 'traditional-json'
  - 'sarif-json'
  - 'pdf' 
variables:
  devUrl: 'http://testphp.vulnweb.com'
  qaUrl: 'https://qa-agent.app-np.neovance.com/'
  prodUrl: 'http://my-prod-app.com'
stages:
- stage: ZAP_Scan_Stage
  displayName: 'Run ZAP Scan'
  jobs:
  - job: ZAP_Scan_Job
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        echo "Starting ZAP Scan..."
        echo "Environment: ${{ parameters.environment }}"
        echo "Scan Type: ${{ parameters.scanType }}"
        echo "Report Template: ${{ parameters.reportTemplate }}"
        
        # Pick target URL
        if [ "${{ parameters.environment }}" == "dev" ]; then
          TARGET_URL="${{ variables.devUrl }}"
        elif [ "${{ parameters.environment }}" == "qa" ]; then
          TARGET_URL="${{ variables.qaUrl }}"
        elif [ "${{ parameters.environment }}" == "prod" ]; then
          TARGET_URL="${{ variables.prodUrl }}"
        else
          echo "Invalid environment"; exit 1
        fi
        
        echo "Target URL: $TARGET_URL"
        
        # Work dir inside pipeline  
        mkdir -p $(Build.ArtifactStagingDirectory)
        cd $(Build.ArtifactStagingDirectory)
        
        echo "Working directory: $(pwd)"
        
        # Run ZAP scan based on type - using simple approach to avoid permission issues
        if [ "${{ parameters.scanType }}" == "baseline" ]; then
          echo "Running ZAP Baseline Scan..."
          docker run --rm -v $(pwd):/zap/wrk:rw ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
            -t $TARGET_URL \
            -g gen.conf \
            -r testreport.html \
            -x report.xml \
            -J report.json \
            -d || true
            
        elif [ "${{ parameters.scanType }}" == "full" ]; then
          echo "Running ZAP Full Scan..."
          docker run --rm -v $(pwd):/zap/wrk:rw ghcr.io/zaproxy/zaproxy:stable \
            zap-full-scan.py \
            -t $TARGET_URL \
            -g gen.conf \
            -r testreport.html \
            -x report.xml \
            -J report.json \
            -d || true
            
        elif [ "${{ parameters.scanType }}" == "api" ]; then
          echo "Running ZAP API Scan..."
          docker run --rm -v $(pwd):/zap/wrk:rw ghcr.io/zaproxy/zaproxy:stable \
            zap-api-scan.py \
            -t $TARGET_URL \
            -f openapi \
            -g gen.conf \
            -r testreport.html \
            -x report.xml \
            -J report.json \
            -d || true
        fi
        
        echo "ZAP scan completed. Checking generated files..."
        ls -la
        
        # Determine final report filename based on template preference
        case "${{ parameters.reportTemplate }}" in
          modern|traditional-html|traditional-html-plus)
            FINAL_REPORT="zap_${{ parameters.scanType }}_report.html"
            SOURCE_FILE="testreport.html"
            ;;
          traditional-json|sarif-json)
            FINAL_REPORT="zap_${{ parameters.scanType }}_report.json"
            SOURCE_FILE="report.json"
            ;;
          *)
            FINAL_REPORT="zap_${{ parameters.scanType }}_report.html"
            SOURCE_FILE="testreport.html"
            ;;
        esac
        
        # Copy/rename the report files
        REPORT_CREATED=false
        
        if [ -f "$SOURCE_FILE" ]; then
          cp "$SOURCE_FILE" "$FINAL_REPORT"
          echo "‚úÖ Primary report created: $FINAL_REPORT"
          echo "Report size: $(du -h $FINAL_REPORT)"
          REPORT_CREATED=true
        fi
        
        # Also copy other formats if they exist
        if [ -f "testreport.html" ] && [ "$SOURCE_FILE" != "testreport.html" ]; then
          cp "testreport.html" "zap_${{ parameters.scanType }}_report.html"
          echo "‚úÖ HTML report created: zap_${{ parameters.scanType }}_report.html"
        fi
        
        if [ -f "report.xml" ]; then
          cp "report.xml" "zap_${{ parameters.scanType }}_report.xml"
          echo "‚úÖ XML report created: zap_${{ parameters.scanType }}_report.xml"
        fi
        
        if [ -f "report.json" ] && [ "$SOURCE_FILE" != "report.json" ]; then
          cp "report.json" "zap_${{ parameters.scanType }}_report.json"
          echo "‚úÖ JSON report created: zap_${{ parameters.scanType }}_report.json"
        fi
        
        if [ -f "gen.conf" ]; then
          cp "gen.conf" "zap_${{ parameters.scanType }}_config.conf"
          echo "‚úÖ Config file saved: zap_${{ parameters.scanType }}_config.conf"
        fi
        
        # Final file listing
        echo "Final files in artifact directory:"
        ls -la
        
        if [ "$REPORT_CREATED" = true ]; then
          echo "üéâ ZAP scan completed successfully!"
          echo "Primary report: $FINAL_REPORT"
        else
          echo "‚ö†Ô∏è  No reports were generated, but scan may have completed"
          echo "This could happen if the target was unreachable or scan failed"
        fi
        
      displayName: 'Run ZAP Scan with Docker (Simple)'
      
    - publish: '$(Build.ArtifactStagingDirectory)'
      artifact: 'ZAP_Reports_${{ parameters.environment }}'
      displayName: 'Publish ZAP Scan Reports'
      condition: always()
      
    - task: PublishTestResults@2
      displayName: 'Publish ZAP Test Results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/*report.xml'
        searchFolder: '$(Build.ArtifactStagingDirectory)'
        mergeTestResults: false
        failTaskOnFailedTests: false
        testRunTitle: 'ZAP Security Scan Results - ${{ parameters.environment }}'
      condition: always()
      continueOnError: true